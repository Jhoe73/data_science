import os
import sqlite3
import pandas as pd
from datetime import datetime, timedelta
import streamlit as st

# Diretório do banco de dados (dentro da pasta 'dbs')
CURRENT_DIR = os.getcwd()
DB_DIR = os.path.join(CURRENT_DIR, 'dbs')

# Cria o diretório 'dbs' se ele não existir
os.makedirs(DB_DIR, exist_ok=True)

DATABASE_PATH = os.path.join(DB_DIR, 'login_logout_records.db')

def initialize_database():
    # Conecta ao banco de dados
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()

    # Cria a tabela 'events' se ela não existir
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_type TEXT NOT NULL,
            timestamp TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

def get_all_login_logout_data():
    # Conecta ao banco de dados
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()

    # Obtém todos os logs no banco de dados
    cursor.execute('''
        SELECT event_type, timestamp 
        FROM events 
        ORDER BY timestamp
    ''')

    events = cursor.fetchall()
    conn.close()
    return events

def create_dataframe(events):
    # Variáveis para armazenar registros importantes
    records = []
    last_logout = None
    long_intervals = []

    # Dicionário para armazenar primeiro in e último out por data
    daily_first_login = {}
    daily_last_logout = {}
    daily_intervals = {}

    # Processa todos os eventos
    for event_type, timestamp in events:
        event_time = datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S")
        date_str = event_time.strftime("%Y-%m-%d")
        time_str = event_time.strftime("%H:%M:%S")

        # Registra o primeiro 'in' do dia
        if event_type == 'in':
            if date_str not in daily_first_login:
                daily_first_login[date_str] = event_time

        # Registra o último 'out' do dia
        elif event_type == 'out':
            daily_last_logout[date_str] = event_time

        # Adiciona intervalos de tempo entre 'out' e o próximo 'in' com mais de 30 minutos de diferença
        if last_logout and event_type == 'in':
            if (event_time - last_logout > timedelta(minutes=30)):
                long_intervals.append((last_logout, event_time))
                # Armazena os intervalos para o cálculo de tempo total de intervalo
                if date_str not in daily_intervals:
                    daily_intervals[date_str] = []
                daily_intervals[date_str].append((last_logout, event_time))
        
        # Atualiza o último logout
        if event_type == 'out':
            last_logout = event_time

    # Adiciona as entradas e saídas ao registro
    for date_str in daily_first_login:
        first_login = daily_first_login[date_str]
        records.append({'data': date_str, 'acao': 'entrada', 'hora': first_login.strftime("%H:%M:%S")})
    
    for date_str in daily_last_logout:
        last_logout = daily_last_logout[date_str]
        records.append({'data': date_str, 'acao': 'saida', 'hora': last_logout.strftime("%H:%M:%S")})

    # Adiciona intervalos maiores que 30 minutos
    for out_time, in_time in long_intervals:
        records.append({'data': out_time.strftime("%Y-%m-%d"), 'acao': 'ida intervalo', 'hora': out_time.strftime("%H:%M:%S")})
        records.append({'data': in_time.strftime("%Y-%m-%d"), 'acao': 'volta intervalo', 'hora': in_time.strftime("%H:%M:%S")})

    # Cria um DataFrame com os registros
    df = pd.DataFrame(records, columns=['data', 'acao', 'hora'])

    # Ordena as ações: entrada, ida intervalo, volta intervalo, saida
    action_order = {'entrada': 1, 'ida intervalo': 2, 'volta intervalo': 3, 'saida': 4}
    df['acao_order'] = df['acao'].map(action_order)
    df = df.sort_values(by=['data', 'acao_order', 'hora']).drop(columns=['acao_order'])

    # Calcula horas trabalhadas, tempo de intervalo e diferença de 8 horas por dia
    work_summary = []
    for date_str in daily_first_login:
        first_in = daily_first_login[date_str]
        last_out = daily_last_logout.get(date_str, None)
        total_interval_hours = 0
        
        # Calcula o tempo total de intervalos
        if date_str in daily_intervals:
            for interval in daily_intervals[date_str]:
                out_time, in_time = interval
                total_interval_hours += (in_time - out_time).total_seconds() / 3600

        if last_out:
            total_worked_hours = (last_out - first_in).total_seconds() / 3600  # Convert to hours
            total_worked_hours -= total_interval_hours  # Subtrai o tempo de intervalo das horas trabalhadas

            work_summary.append({
                'data': date_str,
                'horas_trabalhadas': round(total_worked_hours, 2),
                'tempo_intervalo': round(total_interval_hours, 2),
                'diferenca_8h': round(total_worked_hours - 8, 2)
            })
    
    work_summary_df = pd.DataFrame(work_summary)
    df = df.merge(work_summary_df, on='data', how='left')

    return df

def main():
    # Inicializa o banco de dados e a tabela se necessário
    initialize_database()

    # Obtém todos os eventos
    events = get_all_login_logout_data()
    if not events:
        st.write("Nenhum evento de login/logout encontrado.")
        return

    df = create_dataframe(events)

    # Filtros com Streamlit
    st.sidebar.header('Filtros')
    filter_date = st.sidebar.date_input('Filtrar por data', None)
    filter_action = st.sidebar.multiselect('Filtrar por ação', ['entrada', 'ida intervalo', 'volta intervalo', 'saida'], default=['entrada', 'ida intervalo', 'volta intervalo', 'saida'])

    if filter_date:
        df = df[df['data'] == filter_date.strftime('%Y-%m-%d')]
    
    df = df[df['acao'].isin(filter_action)]

    # Mostrar o DataFrame resultante com Streamlit
    st.dataframe(df)

if __name__ == "__main__":
    main()
