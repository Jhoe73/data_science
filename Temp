import os
import sqlite3
import pandas as pd
from datetime import datetime, timedelta
import streamlit as st

# Diretório do banco de dados (dentro da pasta 'dbs')
CURRENT_DIR = os.getcwd()
DB_DIR = os.path.join(CURRENT_DIR, 'dbs')

# Cria o diretório 'dbs' se ele não existir
os.makedirs(DB_DIR, exist_ok=True)

DATABASE_PATH = os.path.join(DB_DIR, 'login_logout_records.db')

def initialize_database():
    # Conecta ao banco de dados
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()

    # Cria a tabela 'events' se ela não existir
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_type TEXT NOT NULL,
            timestamp TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

def get_all_login_logout_data():
    # Conecta ao banco de dados
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()

    # Obtém todos os logs no banco de dados
    cursor.execute('''
        SELECT event_type, timestamp 
        FROM events 
        ORDER BY timestamp
    ''')

    events = cursor.fetchall()
    conn.close()
    return events

def create_dataframe(events):
    # Variáveis para armazenar registros importantes
    records = []
    last_logout = None
    first_login = None
    long_intervals = []

    # Dicionário para armazenar primeiro in e último out por data
    daily_first_login = {}
    daily_last_logout = {}

    # Processa todos os eventos
    for event_type, timestamp in events:
        event_time = datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S")
        date_str = event_time.strftime("%Y-%m-%d")
        time_str = event_time.strftime("%H:%M:%S")

        # Registra o primeiro 'in' do dia
        if event_type == 'in':
            if date_str not in daily_first_login:
                daily_first_login[date_str] = event_time

        # Registra o último 'out' do dia
        elif event_type == 'out':
            daily_last_logout[date_str] = event_time

        # Adiciona intervalos de tempo entre 'out' e o próximo 'in' com mais de 30 minutos de diferença
        if last_logout and event_type == 'in':
            if (event_time - last_logout > timedelta(minutes=30)):
                long_intervals.append((last_logout, event_time))
        
        # Atualiza o último logout
        if event_type == 'out':
            last_logout = event_time

    # Adiciona as primeiras entradas e últimas saídas ao registro
    for date_str in daily_first_login:
        first_login = daily_first_login[date_str]
        records.append({'data': date_str, 'acao': 'primeira entrada', 'hora': first_login.strftime("%H:%M:%S")})
    
    for date_str in daily_last_logout:
        last_logout = daily_last_logout[date_str]
        records.append({'data': date_str, 'acao': 'ultima saida', 'hora': last_logout.strftime("%H:%M:%S")})

    # Adiciona intervalos maiores que 30 minutos
    for out_time, in_time in long_intervals:
        records.append({'data': out_time.strftime("%Y-%m-%d"), 'acao': 'ida intervalo', 'hora': out_time.strftime("%H:%M:%S")})
        records.append({'data': in_time.strftime("%Y-%m-%d"), 'acao': 'volta intervalo', 'hora': in_time.strftime("%H:%M:%S")})

    # Cria um DataFrame com os registros
    df = pd.DataFrame(records, columns=['data', 'acao', 'hora'])
    return df

def main():
    # Inicializa o banco de dados e a tabela se necessário
    initialize_database()

    # Obtém todos os eventos
    events = get_all_login_logout_data()
    if not events:
        st.write("Nenhum evento de login/logout encontrado.")
        return

    df = create_dataframe(events)

    # Mostrar o DataFrame resultante com Streamlit
    st.dataframe(df)

if __name__ == "__main__":
    main()
